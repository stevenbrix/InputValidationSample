// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

using System;
using System.Numerics;
using System.Threading.Tasks;
using Windows.Foundation;
using Windows.UI.Xaml;
using Windows.UI.Xaml.Controls;
using System.ComponentModel;
using System.Runtime.CompilerServices;
using System.Collections.Generic;
using System.Linq;
using System.ComponentModel.DataAnnotations;
using System.Collections;
using InputValidationSample.ViewModel;
using Microsoft.UI.Xaml.Controls;

namespace InputValidationSample
{
    public sealed partial class InputValidationPage : Page
    {
        public InputValidationPage()
        {
            ViewModel = new PurchaseViewModel();
            this.InitializeComponent();
        }

        public static readonly DependencyProperty ViewModelProperty = DependencyProperty.Register("ViewModel", typeof(PurchaseViewModel), typeof(InputValidationPage), new PropertyMetadata(null));

        public PurchaseViewModel ViewModel
        {
            get { return GetValue(ViewModelProperty) as PurchaseViewModel; }
            set { SetValue(ViewModelProperty, value); }
        }

        private void UserControl_Loaded(object sender, RoutedEventArgs e)
        {
            ViewModel.ErrorsChanged += ViewModel_ErrorsChanged;

        }

        // This is the code that roughly imitates what is generated by x:Bind
        private void ViewModel_ErrorsChanged(object sender, DataErrorsChangedEventArgs e)
        {
            if (sender is INotifyDataErrorInfo errorInfo)
            {
                switch (e.PropertyName)
                {
                    case "Name":
                        AddErrors(errorInfo, "Name", CardHolderNameField);
                        break;
                    case "City":
                        AddErrors(errorInfo, "City", CityField);
                        break;
                    case "CardNumber":
                        AddErrors(errorInfo, "CardNumber", CardNumberField);
                        break;
                    case "Address":
                        AddErrors(errorInfo, "Address", AddressField);
                        break;
                    case "Zip":
                        AddErrors(errorInfo, "Zip", ZipCodeField);
                        break;
                    case "CCV":
                        AddErrors(errorInfo, "CCV", CCVField);
                        break;
                    default:
                        break;
                }
            }
        }

        private void AddErrors(INotifyDataErrorInfo sender, string propertyName, IInputValidationControl ctrl)
        {
            // This mirrors the WPF behavior where the errors collection is cleared and re-populated each time.
            // This assumes that there is only one property that takes place in validation. If we want to add more
            // we'd have to come up with a means to associate a particual ValidationError with the property as well
            // as have a list of ValidationContext objects.
            ctrl.ValidationErrors.Clear();
            foreach (var error in sender.GetErrors(propertyName))
            {
                InputValidationError validationError = error as InputValidationError;
                if (validationError == null)
                {
                    // Either this is a string itself, or a DataAnnotation.ValidationResult. Either way we can just
                    // use ToString to get the message
                    validationError = new InputValidationError(error.ToString());
                }
                ctrl.ValidationErrors.Add(validationError);
            }
        }
    }

    
}
